/*
 * This is free and unencumbered software released into the public domain.
 *
 * Anyone is free to copy, modify, publish, use, compile, sell, or
 * distribute this software, either in source code form or as a compiled
 * binary, for any purpose, commercial or non-commercial, and by any
 * means.
 *
 * In jurisdictions that recognize copyright laws, the author or authors
 * of this software dedicate any and all copyright interest in the
 * software to the public domain. We make this dedication for the benefit
 * of the public at large and to the detriment of our heirs and
 * successors. We intend this dedication to be an overt act of
 * relinquishment in perpetuity of all present and future rights to this
 * software under copyright law.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * For more information, please refer to <https://unlicense.org>
 */
package matinilad.gefrase;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import javax.swing.DefaultListModel;
import javax.swing.event.ListSelectionEvent;

/**
 * A classe da janela de seleção de palavra
 * 
 * A janela de seleção de palavra também suporta números em hexadecimal
 * já que se um dicionário não possuir uma potência de 2 em tamanho
 * uma palavra de recuperação pode ser calculada para um índice fora dele.
 * 
 * Se um índice for negativo ele cancela a seleção atual.
 * @author Cien
 */
@SuppressWarnings("serial")
public class SelectWord extends javax.swing.JDialog {

    //classe de uma palavra para ser selecionada
    private static class Word {
        
        //o dicionário
        private final Dictionary dictionary;
        //o índice da palavra
        private final int wordIndex;

        public Word(Dictionary dictionary, int wordIndex) {
            this.dictionary = dictionary;
            this.wordIndex = wordIndex;
        }

        public Dictionary getDictionary() {
            return dictionary;
        }

        public int getWordIndex() {
            return wordIndex;
        }

        @Override
        public String toString() {
            if (this.wordIndex < 0) {
                return "Remover seleção atual";
            }
            if (this.wordIndex >= this.dictionary.getNumberOfWords()) {
                return "Número em Hexadecimal (0x"+Integer.toHexString(this.wordIndex).toUpperCase()+")";
            }
            return this.dictionary.getWord(this.wordIndex);
        }
        
    }
    
    //o dicionário da janela de seleção de palavra
    private final Dictionary dictionary;
    
    /**
     * Cria uma nova janela de seleção de palavra
     * @param parent a janela de diálogo pai dessa janela de seleção, pode ser null
     * @param dictionary o dicionário, não pode ser null
     */
    public SelectWord(java.awt.Dialog parent, Dictionary dictionary) {
        super(parent, true);
        this.dictionary = Objects.requireNonNull(dictionary);
        initComponents();
        updateList();
        setLocationRelativeTo(parent);
    }

    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        searchWordField = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        wordList = new javax.swing.JList<>();
        okButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Selecionar Palavra");
        setMinimumSize(new java.awt.Dimension(300, 200));

        searchWordField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                searchWordFieldKeyReleased(evt);
            }
        });

        wordList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        wordList.addListSelectionListener(this::onItemSelected);
        jScrollPane1.setViewportView(wordList);

        okButton.setText("OK");
        okButton.setEnabled(false);
        okButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                okButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 388, Short.MAX_VALUE)
                    .addComponent(searchWordField, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(okButton)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(searchWordField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 231, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(okButton)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    /**
     * O callback para quando uma palavra for selecionada
     * @param index O índice da palavra selecionada
     */
    public void onWordSelected(int index) {
        
    }
    
    //quando uma tecla no campo de pesquisa for solta a lista de seleção é atualizada
    private void searchWordFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_searchWordFieldKeyReleased
        updateList();
    }//GEN-LAST:event_searchWordFieldKeyReleased
    
    //quando o botão de OK é pressionado a janela é fechada
    //e o callback é chamado para a palavra selecionada
    //se nada for selecionado, nada acontece
    private void okButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okButtonActionPerformed
        Word selected = this.wordList.getSelectedValue();
        if (selected != null) {
            setVisible(false);
            dispose();
            onWordSelected(selected.getWordIndex());
        }
    }//GEN-LAST:event_okButtonActionPerformed
    
    //quando um item for selecionado o botão OK é liberado
    private void onItemSelected(ListSelectionEvent e) {
        if (!e.getValueIsAdjusting()) {
            this.okButton.setEnabled(true);
        }
    }
    
    //atualiza a lista de seleção com o conteúdo do campo de pesquisa
    private void updateList() {
        //primeiro damos prioridade para as palavras iguais a pesquisa
        List<Word> equalsList = new ArrayList<>();
        //depois para as palavras que começam com a pesquisa
        List<Word> startsWithList = new ArrayList<>();
        //depois para as palavras que contém a pesquisa
        List<Word> containsList = new ArrayList<>();
        
        //o texto do campo de pesquisa recebe um trim e é convertido pra lower case
        String search = this.searchWordField.getText().trim().toLowerCase();
        
        //se o texto começa com 0x, então temos um número em hexadecimal e apenas um resultado
        if (search.startsWith("0x")) {
            try {
                int number = Integer.parseInt(search.substring(2), 16);
                if (number < 0) {
                    number = -1;
                }
                equalsList.add(new Word(this.dictionary, number));
            } catch (NumberFormatException ex) {}
        } else {
            //se não, iteramos por todas as palavras do dicionário
            for (int i = 0; i < this.dictionary.getNumberOfWords(); i++) {
                String word = this.dictionary.getWord(i).toLowerCase();
                Word w = new Word(this.dictionary, i);
                if (word.equals(search)) {
                    equalsList.add(w);
                } else if (word.startsWith(search)) {
                    startsWithList.add(w);
                } else if (word.contains(search)) {
                    containsList.add(w);
                }
            }
        }
        
        //todas as listas são ordenadas para melhor visualização
        equalsList.sort((o1, o2) -> String.CASE_INSENSITIVE_ORDER.compare(o1.toString(), o2.toString()));
        startsWithList.sort((o1, o2) -> String.CASE_INSENSITIVE_ORDER.compare(o1.toString(), o2.toString()));
        containsList.sort((o1, o2) -> String.CASE_INSENSITIVE_ORDER.compare(o1.toString(), o2.toString()));
        
        //cria um modelo para a lista de seleção receber as novas palavras
        //e adiciona todas as listas em ordem como dito acima
        DefaultListModel<Word> model = new DefaultListModel<>();
        model.addAll(equalsList);
        model.addAll(startsWithList);
        model.addAll(containsList);
        this.wordList.setModel(model);
        this.wordList.clearSelection();
        
        //desativa o botão de OK (até uma palavra ser selecionada na lista)
        this.okButton.setEnabled(false);
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JButton okButton;
    private javax.swing.JTextField searchWordField;
    private javax.swing.JList<Word> wordList;
    // End of variables declaration//GEN-END:variables
}
